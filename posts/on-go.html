<div style="font-family:Arial,sans-serif;">
  <h2>On Go</h2>

  <p>Go tries to uniquely solve 3 problems for large teams writing huge multi-threaded programs:</p>
  <ol>
    <li>Code gets way harder to maintain as soon as you step into the realm of multi-threading.</li>
    <p>
    Humans are built to understand the world as a story of sequential events.  Multi-threaded code throws that model of reality out the window.  So for multi-threaded code, it's <em>even more important</em> than usual for people to easily visualize what's going on inside it. Go's stripped-down, transparent language features make it easier to deeply understand multi-threaded programs.
    </p>
    <p>
    All Go programs are limited to a tiny number of concurrency primitives with well-known behaviors, and further, no one is allowed to use inheritance/generics to mix complexity into any data structures.  So when you look at anyone's Go code, you're automatically assured that nothing too crazy is going on, and that concurrency primitives will behave the same way, no matter what.  Of course, that also makes Go frustratingly verbose at times.
    </p>
    <p>
    Nick Snyder wrote a great
    <a target="_blank" href="https://www.quora.com/Scala-vs-Go-Could-people-help-compare-contrast-these-on-relative-merits-demerits">Quora answer</a> on the subject of eloquence vs maintainability.
    </p>

    <li>Knowledge of abstractions is lost as devs switch teams/companies.  One person's promotion becomes another's hunk of incomprehensible garbage to debug.</li>
    <p>
    Go encourages you to stop worrying about writing/integrating the One Abstraction to Rule Them All and keep building with its tiny set of simple building blocks.  Example: when I started with Go, I made a generic group-by function like Python's itertools.groupby.  It worked, had 100% test coverage, and was fast-ish.  But it took almost the same amount of code to call my generic iterator as it did to write a hand-tuned loop to accomplish the same thing.  Plus (as a reviewer pointed out), my supposedly-generic code wasn't generic enough to cover myriad cases that arise in certain concurrency patterns.
    </p>
    <p>
    It feels like Go is begging you "Please just solve it for yourself and move on; don't try to force your solution on others."  If you really do need to expose an abstraction to others, Go gives you interfaces (basically sets of methods), which grant your downstream dependencies great flexibility in integrating your abstraction.
    </p>

    <li>It's bad when your team must spend 30+ minutes waiting for code to compile/test/deploy, just so they can test tiny changes.</li>
    <p>
    This is just icing on the cake.
    </p>
    <p>
    Long compile/test/deploy times incentivize devs to discard features and/or cut corners, especially when there's a tight deadline.  Obviously, the faster you can iterate, the better off you are.  Go compiles much faster than C++ in general, but throw in multi-threading with accurate race detection, and the difference is even greater.  Go's <a target="_blank" href="https://blog.golang.org/race-detector">race detector</a> guarantees 0 false positives (which I'm not sure is even possible to do in other languages) and it only increases run time and memory usage by like 10X while it's active.
    </p>
  </ol>

  <br/>
  <p><strong>Conclusion</strong></p>
  <p>
  Problems #2 and #3 probably do not apply to developers at all but the biggest companies.  And #1 isn't a huge problem if you're lightly using a concurrency library/abstraction that everyone on your team knows very well.  Go is awesome, but it's definitely not for everyone.
  </p>
</div>
